%YAML 1.2
---
# Syntax: sublimetext.com/docs/syntax.html

name: Pkl
file_extensions: [pkl, pcf]
scope: source.pkl

variables:
  digits: '(?:\d[\d_]*\d|\d)'
  bits: '(?:[0-1][0-1_]*[0-1]|[0-1])'
  octets: '(?:[0-7][0-7_]*[0-7]|[0-7])'
  hexa: '(?:[\da-fA-F][\da-fA-F_]*[\da-fA-F]|[\da-fA-F_])'

  ident: '(?:[\p{L}_$][\p{L}0-9_$]*\b)' # can't start with a number
  # baseType: '(?:{{ident}}\s*(?:<[^>]*>)?\s*(?:\([^)]*\))?\s*\??)' # eg: Listing<Mapping>(something)?
  baseType: '(?:\*?{{ident}}\s*(?:<[^>]*>)?)' # eg: Listing<Mapping>
  type: '(?:{{baseType}}\s*(\|\s*{{baseType}})*)' # eg: Listing<Float>|Mapping<Int>?|Duration

contexts:
  main:
    - include: typealias
    - include: forPattern
    - include: newPattern
    - include: isPattern
    - include: functions
    - include: lambda-function
    - include: class
    - include: comments
    - include: strings
    - include: keyword
    - include: literal
    - include: number
    - include: super
    - include: operator
    - include: quoted-identifiers
    - include: identifiers

  comments:
    - match: //.*
      scope: comment.line.pkl
    - match: '/\*'
      scope: punctuation.definition.comment.begin.pkl
      push:
        - meta_content_scope: comment.block.pkl
        - match: '\*/'
          scope: punctuation.definition.comment.end.pkl
          pop: true
    - match: '\*/'
      scope: invalid.illegal.pkl

  escaped-char:
    - match: '[\\"tnr]'
      scope: constant.character.escape.pkl
      pop: true
    - match: 'u\{[\da-fA-F]{1,6}\}'
      scope: constant.character.escape.unicode.pkl
      pop: true

  string-interpolation:
    - match: \(
      scope: punctuation.section.interpolation.begin.pkl
      push:
        - clear_scopes: 1
        - meta_scope: meta.interpolation.pkl
        - match: \)
          scope: punctuation.section.interpolation.end.pkl
          pop: 2 # pops both the ( and the {escape-char}
        - include: main

  escape-char-0:
    - match: '\\'
      scope: constant.character.escape.pkl
      push:
        - include: string-interpolation
        - include: escaped-char

  escape-char-1:
    - match: '\\#'
      scope: constant.character.escape.pkl
      push:
        - include: string-interpolation
        - include: escaped-char

  escape-char-2:
    - match: '\\##'
      scope: constant.character.escape.pkl
      push:
        - include: string-interpolation
        - include: escaped-char

  strings:
    - include: string-multi-line-2
    - include: string-single-line-2
    - include: string-multi-line-1
    - include: string-single-line-1
    - include: string-multi-line-0
    - include: string-single-line-0

  string-single-line-0:
    - match: '"'
      scope: meta.string.pkl string.quoted.double.0.pkl punctuation.definition.string.begin.0.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.double.0.pkl
        - match: '"'
          scope: meta.string.pkl string.quoted.double.0.pkl punctuation.definition.string.end.0.pkl
          pop: true
        - include: escape-char-0

  string-single-line-1:
    - match: '#"'
      scope: meta.string.pkl string.quoted.double.1.pkl punctuation.definition.string.begin.1.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.double.1.pkl
        - match: '"#'
          scope: meta.string.pkl string.quoted.double.1.pkl punctuation.definition.string.end.1.pkl
          pop: true
        - include: escape-char-1

  string-single-line-2:
    - match: '##"'
      scope: meta.string.pkl string.quoted.double.2.pkl punctuation.definition.string.begin.2.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.double.2.pkl
        - match: '"##'
          scope: meta.string.pkl string.quoted.double.2.pkl punctuation.definition.string.end.2.pkl
          pop: true
        - include: escape-char-2

  string-multi-line-0:
    - match: '(""")\s*?$' # content must start on a new line
      scope: meta.string.pkl string.quoted.triple.0.pkl punctuation.definition.string.begin.0.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.triple.0.pkl
        - match: '^\s*?(""")' # closing delim must start on a new line
          scope: meta.string.pkl string.quoted.triple.0.pkl punctuation.definition.string.end.0.pkl
          pop: true
        - include: escape-char-0

  string-multi-line-1:
    - match: '(#""")\s*?$' # content must start on a new line
      scope: meta.string.pkl string.quoted.triple.1.pkl punctuation.definition.string.begin.1.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.triple.1.pkl
        - match: '^\s*?("""#)' # closing delim must start on a new line
          scope: meta.string.pkl string.quoted.triple.1.pkl punctuation.definition.string.end.1.pkl
          pop: true
        - include: escape-char-1

  string-multi-line-2:
    - match: '(##""")\s*?$' # content must start on a new line
      scope: meta.string.pkl string.quoted.triple.2.pkl punctuation.definition.string.begin.2.pkl
      push:
        - meta_content_scope: meta.string.pkl string.quoted.triple.2.pkl
        - match: '^\s*?("""##)' # closing delim must start on a new line
          scope: meta.string.pkl string.quoted.triple.2.pkl punctuation.definition.string.end.2.pkl
          pop: true
        - include: escape-char-2

  number:
    - match: '\b(?:{{digits}}?\.{{digits}}(?:[eE][+-]?{{digits}})?|{{digits}}[eE][+-]?{{digits}})\b'
      scope: constant.numeric.float.pkl
    - match: '\b(?:0[xX]){{hexa}}\b'
      scope: constant.numeric.integer.hex.pkl
    - match: '\b(?:0[bB]){{bits}}\b'
      scope: constant.numeric.integer.binary.pkl
    - match: '\b(?:0[oO]){{octets}}\b'
      scope: constant.numeric.integer.octal.pkl
    - match: '\b{{digits}}\b'
      scope: constant.numeric.integer.decimal.pkl

  literal:
    - match: \b(true|false)\b
      scope: constant.language.boolean.pkl
    - match: \b(null)\b
      scope: constant.language.null.pkl
    - match: \b(NaN)\b
      scope: constant.language.nan.pkl
    - match: \b(Infinity)\b
      scope: constant.language.infinity.pkl

  operator:
    - match: '\|>|\?\.|\?\?|!!|\->|\|'
      scope: keyword.operator.pkl
    - match: '(==|!=|<=|>=|>|<)'
      scope: keyword.operator.comparison
    - match: '='
      scope: keyword.operator.assignment
    - match: '(\*\*|[+\-*\/%]|~\/)'
      scope: keyword.operator.arithmetic
    - match: '[~&|^]|<<|>>>?'
      scope: keyword.operator.bitwise
    - match: '\!|\&\&|\|\|'
      scope: keyword.operator.logical

  keyword:
    - match: \b(|protected|override|record|delete|match|case|vararg|const)\b
      scope: keyword.other.pkl
    - match: '\b(read\?|read\*|read|import\*)\b?'
      scope: keyword.import.pkl
    - match: \b(if|else|when)\b
      scope: keyword.control.conditional.pkl
    - match: \b(for)\b
      scope: keyword.control.loop.pkl
    - match: \b(hidden|local|abstract|external|open|in|out|amends|extends|fixed)\b
      scope: storage.modifier.pkl
    - match: \b(class|typealias)\b
      scope: storage.type.class.pkl keyword.declaration.class.pkl
    - match: '\b(amends|as|extends|function|is|let|read|import|throw|trace|module)\b'
      scope: keyword.pkl
    - match: \b(this|outer|super)\b
      scope: variable.language.pkl

  punctuation:
    - match: \,
      scope: punctuation.separator.comma.pkl
    - match: \;
      scope: punctuation.terminator.semicolon.pkl
    - match: ':'
      scope: punctuation.separator.colon.pkl
    - match: \(
      scope: punctuation.section.parens.begin.pkl
    - match: \)
      scope: punctuation.section.parens.end.pkl
    - match: \[
      scope: punctuation.section.brackets.begin.pkl
    - match: \]
      scope: punctuation.section.brackets.end.pkl
    - match: \?
      scope: punctuation.definition.other.questionmark.pkl

  super:
    - match: \@({{ident}})
      scope: keyword.pkl

  identifiers:
    - match: '({{ident}})\s*(?=`?{)'
      scope: variable.other.object.pkl
      push: after-expression
    - match: '({{ident}})\s*(?=`?=\s*(?:new|\([^)]+\)\s*{))'
      scope: variable.other.object.pkl
      push: after-expression
    - match: '({{ident}})\s*(?=`?=)'
      scope: variable.other.property.pkl
      push: after-expression
    - match: '{{ident}}'
      scope: meta.identifier.pkl
      push: after-expression

  quoted-identifiers:
    - match: '`'
      scope: punctuation.section.quoted.begin.pkl
      push:
        - meta_content_scope: meta.quoted.pkl
        - match: '`'
          scope: punctuation.section.quoted.end.pkl
          pop: true
        - include: identifiers

  type:
    - match: \b(Pair|Collection|List|Set|Map|Listing|Mapping)\b
      scope: storage.type.pkl
      push:
        - match: '(?=<)'
          push: generic-angles
        - match: ''
          pop: true
    - match: \b(U?Int(?:8|16|32)?|String|Uri|Boolean|Float|Number)\b
      scope: storage.type.pkl
    - match: \b(Any|nothing)\b
      scope: storage.type.class.pkl
    - match: '{{ident}}\b'
      scope: entity.name.type.pkl
    - match: '\|'
      scope: punctuation.separator.sequence.pkl
    - match: '\*'
      scope: punctuation.definition.annotation.pkl
    - match: '(?=\()'
      push: type-constraint
    - match: ''
      pop: true

  type-constraint:
    - meta_content_scope: meta.type.constraint.pkl
    - match: '\)'
      scope: punctuation.section.parens.end.pkl
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.pkl
      push: type-constraint-contents

  type-constraint-contents:
    - match: '(?=\))'
      pop: true
    - include: main

  generic-angles:
    - meta_content_scope: meta.generic.pkl
    - match: '>'
      scope: punctuation.definition.generic.end.pkl
      pop: true
    - match: '<'
      scope: punctuation.definition.generic.begin.pkl
      push: generic-angles-contents

  generic-angles-contents:
    - match: '(?=>)'
      pop: true
    - include: type
    - include: generic-angles
    - match: '(,)\s*'
      scope: punctuation.separator.pkl
      push: after-expression

  typealias:
    - match: '(typealias)\s+({{ident}})\s*(=)\s*({{type}})'
      captures:
        0: meta.typealias.pkl
        1: keyword.declaration.class.pkl
        2: entity.name.type.pkl
        3: keyword.operator.assignment.pkl
        4: entity.name.type.pkl

  forPattern:
    - match: '\b(for)\s*\(({{ident}})(?:\s*,\s*({{ident}}))*\s+(in)'
      captures:
        0: meta.block.for.pkl
        1: keyword.control.loop.for.pkl
        2: variable.other.property.pkl
        3: variable.other.property.pkl
        4: storage.modifier.pkl

  functions:
    - match: '\b(function)\s+({{ident}})'
      captures:
        0: meta.function.pkl
        1: keyword.pkl
        2: entity.name.function.pkl

  lambda-function:
    - match: '(\({{ident}}\))\s*\->\s*'
      captures:
        0: meta.function.anonymous.pkl
        1: variable.other.pkl

  class:
    - match: '(?:(open)\s+)?(class)\s+({{ident}})(?:\s*(extends)\s+({{ident}}))?'
      captures:
        0: meta.class.pkl
        1: storage.modifier.pkl keyword.other.pkl
        2: storage.type.class.pkl keyword.declaration.class.pkl
        3: entity.name.class.pkl
        4: storage.modifier.pkl keyword.other.pkl
        5: entity.name.type.pkl

  newPattern:
    - match: '\b(new)\s+({{ident}})?'
      captures:
        1: keyword.pkl
        2: entity.name.type.pkl

  isPattern:
    - match: '(`?)({{ident}})(`?)\s+(is)\s+'
      captures:
        1: punctuation.section.quoted.begin.pkl
        2: variable.other.pkl
        3: punctuation.section.quoted.end.pkl
        4: keyword.pkl
      push: type

  after-expression:
    - match: (\.)(?={{ident}})
      scope: punctuation.accessor.dot.pkl
      push:
        - match: ''
          pop: true
    - match: \s*(:)\s*
      scope: punctuation.separator.pkl
      push: type
    - match: ''
      pop: true
